        // --- MAIN APP ---
        function App() {
            const [user, setUser] = useState(null);
            const [profile, setProfile] = useState(null);
            const [tab, setTab] = useState('castle');
            const [chores, setChores] = useState([]);
            const [coupons, setCoupons] = useState([]);
            const [dates, setDates] = useState([]);
            const [bills, setBills] = useState([]);
            const [ious, setIous] = useState([]);
            const [goals, setGoals] = useState([]);
            const [events, setEvents] = useState([]);
            const [shop, setShop] = useState([]);
            const [activities, setActivities] = useState([]);
            const [announcements, setAnnouncements] = useState([]);
            const [jokes, setJokes] = useState([]);
            const [notes, setNotes] = useState([]);
            const [income, setIncome] = useState({ ducky: 0, pips: 0 });
            const [castle, setCastle] = useState({ name: 'Our Kingdom', kingdomFlag: 'üè∞', duckyFlag: 'üê•', pipsFlag: 'üê¶' });
            const [profiles, setProfiles] = useState({});
            const [settings, setSettings] = useState({});
            const [modals, setModals] = useState({});
            const [conflict, setConflict] = useState(null);
            const [redeem, setRedeem] = useState(null);
            const [selectedBill, setSelectedBill] = useState(null);
            const [isShoppingMode, setShoppingMode] = useState(false);
            const [selectedIOU, setSelectedIOU] = useState(null);
            const [dataLoaded, setDataLoaded] = useState({ chores: false, goals: false });
            const [editingNote, setEditingNote] = useState(null);
            const [editingBill, setEditingBill] = useState(null);
            const [needsOnboarding, setNeedsOnboarding] = useState(false);
            const [subscription, setSubscription] = useState({ status: 'inactive', debug: 'Init' });
            
            // DEBUG STATE
            const [debugLogs, setDebugLogs] = useState([]);
            const addLog = (msg) => setDebugLogs(prev => [...prev, `[${new Date().toLocaleTimeString()}] ${msg}`]);

            const processedHabitsRef = React.useRef(new Set());

            const toggleModal = (m, v) => setModals({...modals, [m]: v});

            useEffect(() => {
                // Removed signInAnonymously to ensure users create accounts with emails for Stripe
                return onAuthStateChanged(auth, (u) => { setUser(u); if(u) setProfile(localStorage.getItem('ducky_pips_profile')); });
            }, []);

            useEffect(() => {
                if (!user) return;
                const subs = [];
                const basePath = `kingdoms/${user.uid}`;

                // Check Init
                subs.push(onSnapshot(doc(db, basePath, 'settings', 'castle'), (s) => {
                    if (s.exists()) { setCastle(s.data()); setNeedsOnboarding(false); } 
                    else { setNeedsOnboarding(true); }
                }));

                const subCol = (n, s) => { const q = s ? query(collection(db, basePath, n), orderBy(s.f, s.o)) : collection(db, basePath, n); subs.push(onSnapshot(q, (r) => { const data = r.docs.map(d => ({ id: d.id, ...d.data() })); if(n==='chores') { setChores(data); setDataLoaded(prev => ({...prev, chores: true})); } else if (n==='goals') { setGoals(data); setDataLoaded(prev => ({...prev, goals: true})); } else if(n==='coupons') setCoupons(data); else if(n==='bills') setBills(data); else if(n==='ious') setIous(data); else if(n==='events') setEvents(data); else if(n==='shopping') setShop(data); else if(n==='activities') setActivities(data); else if(n==='announcements') setAnnouncements(data); else if(n==='datenights') setDates(data); else if(n==='jokes') setJokes(data); else if(n==='notes') setNotes(data); })); };
                subCol('chores', {f:'createdAt',o:'asc'}); subCol('coupons'); subCol('bills'); subCol('ious', {f:'createdAt',o:'desc'}); subCol('goals'); subCol('events'); subCol('shopping'); subCol('activities', {f:'createdAt',o:'desc'}); subCol('announcements', {f:'createdAt',o:'desc'}); subCol('datenights', {f:'createdAt',o:'desc'}); subCol('jokes', {f:'createdAt',o:'desc'}); subCol('notes', {f:'createdAt',o:'desc'});
                
                const subDoc = (n, i, cb) => { subs.push(onSnapshot(doc(db, basePath, n, i), cb)); };
                subDoc('settings', 'income', (s) => setIncome(s.exists() ? s.data() : {ducky:0,pips:0}));
                subDoc('settings', 'profiles', (s) => { if(s.exists()) setProfiles(s.data()); });
                subDoc('settings', 'rewards', (s) => { if (s.exists()) setSettings(prev => ({ ...prev, rewards: s.data() })); });

                // --- STRIPE SUBSCRIPTION LISTENER (Robust & Parallel) ---
                const checkSubscription = () => {
                    // Helper to merge statuses (Priority: Active > Inactive)
                    let sources = { customers: 'waiting', users: 'waiting', claims: 'waiting' };
                    
                    const updateStatus = (source, status, details) => {
                        sources[source] = status;
                        const debugStr = `C:${sources.customers} U:${sources.users} (${details})`;
                        
                        // If any source is active, we are good
                        if (sources.customers === 'active' || sources.users === 'active' || sources.claims === 'active') {
                            setSubscription(prev => ({ ...prev, status: 'active', debug: 'Active: ' + debugStr }));
                        } else if (sources.customers !== 'waiting' && sources.users !== 'waiting') {
                            // Only set inactive if we've heard back from databases and none are active
                            setSubscription(prev => ({ ...prev, status: 'inactive', debug: debugStr }));
                        } else {
                             setSubscription(prev => ({ ...prev, debug: 'Checking... ' + debugStr }));
                        }
                    };

                    // 1. Auth Claims (Fastest)
                    user.getIdTokenResult(true).then(token => {
                        const role = token.claims.stripeRole;
                        // Check if ANY stripe role exists or is 'premium'/'pro'
                        // Some setups use custom claims, others rely on DB.
                        // We check for truthiness of stripeRole as a baseline for 'active'.
                        updateStatus('claims', role ? 'active' : 'inactive', role ? 'Role Found' : 'No Role');
                    });

                    // 2. Customers Collection
                    const custSubRef = collection(db, 'customers', user.uid, 'subscriptions');
                    subs.push(onSnapshot(custSubRef, (snap) => {
                        if (snap.empty) {
                            updateStatus('customers', 'inactive', 'No docs');
                        } else {
                            const activeDoc = snap.docs.find(d => ['active', 'trialing'].includes(d.data().status));
                            updateStatus('customers', activeDoc ? 'active' : 'inactive', activeDoc ? 'Found Active' : `Status: ${snap.docs[0].data().status}`);
                        }
                    }, (err) => updateStatus('customers', 'error', err.message)));

                    // 3. Users Collection (Fallback)
                    const userSubRef = collection(db, 'users', user.uid, 'subscriptions');
                    subs.push(onSnapshot(userSubRef, (snap) => {
                         if (snap.empty) {
                            updateStatus('users', 'inactive', 'No docs');
                        } else {
                            const activeDoc = snap.docs.find(d => ['active', 'trialing'].includes(d.data().status));
                            updateStatus('users', activeDoc ? 'active' : 'inactive', activeDoc ? 'Found Active' : 'Docs inactive');
                        }
                    }, (err) => updateStatus('users', 'error', 'perm denied'))); 

                     // Debug: Check if checkout sessions exist (implies write permission is okay)
                    const sessionRef = collection(db, 'customers', user.uid, 'checkout_sessions');
                    subs.push(onSnapshot(sessionRef, (snap) => {
                        if (!snap.empty) {
                           setSubscription(prev => ({ ...prev, checkoutCreated: true }));
                        }
                    }));
                };

                checkSubscription();

                return () => subs.forEach(u => u && u());
            }, [user]);

            const act = async (type, col, id, data = {}) => {
                try {
                    const path = ['kingdoms', user.uid, col];
                    if (type === 'add') {
                        await addDoc(collection(db, ...path), { ...data, createdAt: serverTimestamp() });
                    } else if (type === 'update' && id) {
                        await updateDoc(doc(db, ...path, id), data);
                    } else if (type === 'delete' && id) {
                        if (!confirm("Are you sure you want to delete this?")) return;
                        await deleteDoc(doc(db, ...path, id));
                    } else if (type === 'set' && id) {
                        await setDoc(doc(db, ...path, id), data);
                    }
                } catch (e) {
                    console.error("Firebase Action Error:", e);
                }
            };

            const handleSubscribe = async () => {
                if(!user) return;
                
                setDebugLogs([]); // Clear previous logs
                addLog("üîµ Starting Subscription Process");
                addLog(`User UID: ${user.uid}`);
                addLog(`Email: ${user.email}`);
                addLog(`Is Anonymous: ${user.isAnonymous}`);

                // --- BLOCK GUEST USERS ---
                if (user.isAnonymous) {
                    const err = "‚ö†Ô∏è Guest Account Detected. Stripe requires a valid email address.";
                    addLog(err);
                    alert("Please Sign Out and create a real account to subscribe.");
                    return;
                }

                // Stripe requires HTTP/HTTPS URLs. file:// protocol fails validation.
                let returnUrl = window.location.href;
                addLog(`Return URL: ${returnUrl}`);
                if (window.location.protocol === 'file:') {
                    addLog("‚ö†Ô∏è 'file:' protocol detected. Using fallback URL.");
                    returnUrl = "https://example.com/success"; 
                }

                try {
                    addLog("Preparing payload for Firestore...");
                    const payload = {
                        price: STRIPE_PRICE_ID,
                        success_url: returnUrl,
                        cancel_url: returnUrl,
                        allow_promotion_codes: true, // Enable promo codes
                        // Attempt to pre-fill email for extension mapping
                        customer_email: user.email, 
                        metadata: {
                            firebase_uid: user.uid
                        }
                    };
                    addLog(`Payload: ${JSON.stringify(payload, null, 2)}`);

                    addLog("Writing to 'customers/{uid}/checkout_sessions'...");
                    const docRef = await addDoc(collection(db, 'customers', user.uid, 'checkout_sessions'), payload);
                    
                    addLog(`‚úÖ Document created. ID: ${docRef.id}`);
                    addLog("Listening for Extension response...");

                    onSnapshot(docRef, (snap) => {
                        const data = snap.data();
                        if (!data) {
                            addLog("... waiting for write (pending)");
                            return; 
                        }
                        
                        addLog(`üì• Snapshot Update: ${JSON.stringify(data)}`);
                        
                        const { url, error } = data;
                        if (error) {
                            addLog(`‚ùå ERROR from Extension: ${error.message}`);
                            console.error(error);
                            alert(`Error: ${error.message}`);
                        }
                        if (url) {
                            addLog(`‚úÖ SUCCESS! Redirecting to: ${url}`);
                            window.location.assign(url);
                        }
                    });
                } catch(e) { 
                    addLog(`‚ùå EXCEPTION: ${e.message}`);
                    console.error(e); 
                }
            };

            // NEW: Handle Portal Session Creation
            const handleManageSubscription = async () => {
                if(!user) return;
                setDebugLogs([]);
                addLog("üîµ Opening Billing Portal");
                
                let returnUrl = window.location.href;
                if (window.location.protocol === 'file:') {
                    returnUrl = "https://example.com/success"; 
                }

                try {
                    addLog("Creating 'portal_sessions' doc...");
                    const docRef = await addDoc(collection(db, 'customers', user.uid, 'portal_sessions'), {
                        returnUrl: returnUrl,
                    });
                    
                    addLog(`Doc created: ${docRef.id}. Waiting...`);

                    // Listen for the extension to write the URL
                    onSnapshot(docRef, (snap) => {
                        const data = snap.data();
                        if (!data) return; // Wait for data
                        
                        addLog(`Snapshot: ${JSON.stringify(data)}`);

                        const { url, error } = data;
                        if (error) {
                            addLog(`‚ùå ERROR: ${error.message}`);
                            alert(`Error: ${error.message}`);
                            console.error(error);
                        }
                        if (url) {
                            addLog(`‚úÖ Redirecting to ${url}`);
                            window.location.assign(url);
                        }
                    });
                } catch(e) { 
                    addLog(`‚ùå EXCEPTION: ${e.message}`);
                    console.error(e); 
                    alert("Error opening billing portal: " + e.message);
                }
            };

            const handleInitialization = async (data) => {
                if (!user) return;
                const basePath = `kingdoms/${user.uid}`;
                await setDoc(doc(db, basePath, 'settings', 'castle'), { name: data.kingdomName, kingdomFlag: data.kingdomFlag, duckyFlag: data.p1.icon, pipsFlag: data.p2.icon });
                await setDoc(doc(db, basePath, 'settings', 'profiles'), { Ducky: data.p1, Pips: data.p2 });
                await setDoc(doc(db, basePath, 'settings', 'income'), { ducky: 0, pips: 0 });
                for(const t of data.initialChores) await addDoc(collection(db, basePath, 'chores'), { title: t, frequency: 'Weekly', assignedTo: null, status: 'pending', createdAt: serverTimestamp() });
                setNeedsOnboarding(false);
            };

            const myChores = useMemo(() => chores.filter(c => c.assignedTo === profile && c.status !== 'completed'), [chores, profile]);
            const unassigned = useMemo(() => chores.filter(c => !c.assignedTo && !(c.votes && profile && c.votes[profile])), [chores, profile]);
            const completed = useMemo(() => chores.filter(c => c.status === 'completed'), [chores]);
            const isHouseholdDeed = (c) => { if (c.type === 'whim') return false; if (c.goalId) { const g = goals.find(goal => goal.id === c.goalId); if (g && g.type === 'personal') return false; } return true; };
            const myCount = completed.filter(c => c.completedBy === profile && !c.redeemedForCoupon && isHouseholdDeed(c)).length;
            const totalCount = completed.filter(c => !c.redeemedForDate && isHouseholdDeed(c)).length;
            const myTheme = profile && profiles[profile] ? THEME_COLORS.find(c => c.name === profiles[profile].theme) || THEME_COLORS[0] : THEME_COLORS[0];
            const activeDate = useMemo(() => dates.find(d => d.status !== 'completed'), [dates]);
            const isPro = subscription.status === 'active';

            useEffect(() => { if (!profile || !chores.length) return; const threshold = settings.rewards?.choresPerCoupon || DEFAULT_CHORES_PER_COUPON; const un = completed.filter(c => c.completedBy === profile && !c.redeemedForCoupon && isHouseholdDeed(c)); if (un.length >= threshold) { const ids = un.slice(0, threshold).map(c => c.id); const pool = settings.rewards?.pools?.[profile] || DEFAULT_COUPONS; const randomCoupon = pool[Math.floor(Math.random() * pool.length)]; act('add', 'coupons', null, { title: randomCoupon, owner: profile, isUsed: false }); ids.forEach(id => act('update', 'chores', id, { redeemedForCoupon: true })); } }, [completed, profile, settings.rewards, goals]);
            
            // Habit generation with duplication check using Due Date + Data Loaded check
            useEffect(() => { 
                if (!profile || !goals.length || !dataLoaded.chores || !dataLoaded.goals) return; 
                const myActiveGoals = goals.filter(g => g.owner === profile || g.type === 'shared'); 
                const todayStr = new Date().toISOString().split('T')[0];

                myActiveGoals.forEach(goal => { 
                    if (goal.habits && goal.habits.length > 0) { 
                        goal.habits.forEach(habit => { 
                            const habitTitle = `${habit.text}`; 
                            const uniqueKey = `${goal.id}_${habit.id}_${todayStr}`;

                            if (processedHabitsRef.current.has(uniqueKey)) return;

                            const existsToday = chores.some(c => c.title === habitTitle && c.goalId === goal.id && c.dueDate && c.dueDate.split('T')[0] === todayStr); 
                            
                            if (existsToday) {
                                processedHabitsRef.current.add(uniqueKey);
                            } else if (habit.frequency === 'Daily') { 
                                processedHabitsRef.current.add(uniqueKey);
                                act('add', 'chores', null, { title: habitTitle, assignedTo: profile, type: 'habit', goalId: goal.id, frequency: 'Daily', status: 'pending', dueDate: new Date().toISOString(), createdAt: serverTimestamp() }); 
                            } 
                        }); 
                    } 
                }); 
            }, [goals, profile, chores, dataLoaded]);

            const openAddModal = () => { if (tab === 'budget') toggleModal('bill', true); else if (tab === 'goals') toggleModal('goal', true); else if (tab === 'calendar') toggleModal('event', true); else if (tab === 'shop') toggleModal('shop', true); else if (tab === 'jokes') toggleModal('joke', true); else if (tab === 'notes') toggleModal('note', true); else toggleModal('chore', true); };

            if (!user) return <AuthComponent />;
            if (needsOnboarding) return <Onboarding onComplete={handleInitialization} />;
            if (!profile) return (<div className="min-h-screen bg-pink-50 flex flex-col items-center justify-center p-6 text-center font-sans fade-in"><h1 className="text-5xl font-black text-pink-500 mb-10 drop-shadow-sm tracking-tight animate-bounce-slight">Who are you?</h1><div className="flex gap-8"><button onClick={() => {setProfile('Ducky'); localStorage.setItem('ducky_pips_profile', 'Ducky');}} className="w-44 h-44 bg-themeYellow rounded-[3rem] shadow-cute border-4 border-white flex flex-col items-center justify-center hover:scale-105 transition-transform"><div className="text-7xl mb-2">{profiles.Ducky?.icon || 'üê•'}</div><span className="text-2xl font-black text-themeYellowDark">{profiles.Ducky?.name || 'Ducky'}</span></button><button onClick={() => {setProfile('Pips'); localStorage.setItem('ducky_pips_profile', 'Pips');}} className="w-44 h-44 bg-themeBlue rounded-[3rem] shadow-cute border-4 border-white flex flex-col items-center justify-center hover:scale-105 transition-transform"><div className="text-7xl mb-2">{profiles.Pips?.icon || 'üê¶'}</div><span className="text-2xl font-black text-themeBlueDark">{profiles.Pips?.name || 'Pips'}</span></button></div><button onClick={() => signOut(auth)} className="mt-12 text-gray-400 font-bold text-sm hover:text-red-400 flex items-center gap-2"><LogOut size={16} /> Sign Out</button></div>);

            const historyItems = [...completed.map(c => ({ type: 'chore', who: c.completedBy, date: new Date(c.completedAt?.seconds * 1000 || Date.now()).toISOString(), desc: c.title })), ...dates.map(d => ({ type: 'date', who: 'Both', date: d.date || d.createdAt, desc: d.activity })), ...activities.map(a => ({ type: 'shopping', who: a.who, date: new Date(a.createdAt?.seconds * 1000 || Date.now()).toISOString(), desc: a.description, details: a.items ? a.items.join(', ') : '' }))].sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime());

            return (
                <ErrorBoundary>
                    <div className={`h-[100dvh] w-full flex flex-col font-sans max-w-md mx-auto shadow-2xl overflow-hidden relative fade-in ${myTheme.bg} transition-colors duration-500`}>
                        <header className="bg-white/80 backdrop-blur-md p-5 pt-safe-top pb-4 shadow-sm z-10 flex justify-between items-center select-none rounded-b-[2.5rem] sticky top-0"><div className="flex items-center gap-3"><button onClick={() => toggleModal('profile', true)} className="w-12 h-12 bg-white rounded-full flex items-center justify-center text-2xl shadow-sm border-2 border-gray-100 active:scale-95 transition-transform relative">{profiles[profile]?.icon}<div className="absolute -bottom-1 -right-1 bg-white rounded-full p-0.5 shadow-sm border border-gray-100"><Settings size={10} className="text-gray-400"/></div></button><div><h1 className="text-2xl font-black text-gray-800 tracking-tight flex items-center gap-2">{tab === 'castle' ? "Our Kingdom" : (tab.charAt(0).toUpperCase() + tab.slice(1))}</h1></div></div>
                        <div className="flex gap-2">
                            <button onClick={()=>toggleModal('subscription', true)} className={`p-2 rounded-full transition-colors border shadow-sm ${isPro ? 'bg-yellow-100 text-yellow-600 border-yellow-200' : 'bg-gray-50 text-gray-400 border-gray-100 hover:text-yellow-500'}`}><Star size={20} fill={isPro ? "currentColor" : "none"} /></button>
                            <button onClick={()=>toggleModal('help', true)} className="p-2 bg-blue-50 rounded-full text-blue-600 hover:text-blue-700 transition-colors border border-blue-100 shadow-sm"><CircleHelp size={20}/></button><button onClick={()=>toggleModal('announcement', true)} className="p-2 bg-gray-50 rounded-full text-purple-300 hover:text-purple-500 transition-colors"><Megaphone size={20}/></button><button onClick={() => {setProfile(null); localStorage.removeItem('ducky_pips_profile');}} className="p-2 bg-gray-50 rounded-full text-gray-300 hover:text-red-400 transition-colors"><LogOut size={20} /></button>{(!['rewards', 'dates', 'castle', 'shop', 'calendar', 'jokes', 'notes'].includes(tab) || (isPro && !['rewards', 'dates', 'castle'].includes(tab))) && <button onClick={openAddModal} className="w-12 h-12 bg-black text-white rounded-2xl flex items-center justify-center shadow-cute hover:scale-110 transition-transform active:scale-90"><Plus size={28} strokeWidth={3}/></button>}</div></header>
                        <main className="flex-1 overflow-y-auto p-4 pb-64 relative no-scrollbar overscroll-contain">
                            {tab === 'castle' && <CastleView chores={myChores} completed={completed} events={events} goals={goals} bills={bills} ious={ious} activities={activities} jokes={jokes} notes={notes} user={profile} settings={castle} profiles={profiles} announcements={announcements} onOpenSettings={() => toggleModal('castle', true)} onToggleChore={(c) => act('update', 'chores', c.id, {status: 'completed', completedAt: serverTimestamp(), completedBy: profile})} onOpenMeeting={() => toggleModal('meeting', true)} onOpenHistory={() => toggleModal('history', true)} />}
                            {tab === 'list' && <MyListView chores={myChores} onToggle={(c) => act('update', 'chores', c.id, {status: 'completed', completedAt: serverTimestamp(), completedBy: profile})} onDelete={(id) => act('delete', 'chores', id)} user={profile} progress={myCount} threshold={settings.rewards?.choresPerCoupon || DEFAULT_CHORES_PER_COUPON} onOpenRecurring={() => toggleModal('recurring', true)} />}
                            {tab === 'assign' && <AssignView chores={unassigned} profile={profile} onVote={(id, dir) => { const a=dir==='left'?'Pips':'Ducky'; const c=chores.find(x=>x.id===id); const o=profile==='Ducky'?'Pips':'Ducky'; if(c.votes&&c.votes[o]){ if(c.votes[o]===a) act('update','chores',id,{assignedTo:a,votes:{}}); else { setConflict({title:c.title}); act('update','chores',id,{votes:{},createdAt:serverTimestamp()}); } } else act('update','chores',id,{[`votes.${profile}`]:a}); }} />}
                            {tab === 'dates' && <DateNightView activeDate={activeDate} history={dates.filter(d => d.status === 'completed')} progress={totalCount} onLog={(d) => act('add', 'datenights', null, d)} onUpdateDate={(id, d) => act('update', 'datenights', id, d)} onCompleteDate={(id, d) => act('update', 'datenights', id, d)} resetProgress={(c) => completed.filter(x=>!x.redeemedForDate).sort((a,b)=>(a.completedAt?.seconds||0)-(b.createdAt?.seconds||0)).slice(0,c).forEach(x => act('update', 'chores', x.id, { redeemedForDate: true }))} threshold={settings.rewards?.choresPerDateNight || DEFAULT_CHORES_PER_DATENIGHT} user={profile} completed={completed} bills={bills} goals={goals} activities={activities} events={events} jokes={jokes} notes={notes} ious={ious} profiles={profiles} settings={settings} />}
                            {tab === 'budget' && <BudgetView bills={bills} income={income} ious={ious} user={profile} onUpdateIncome={(d) => act('set', 'settings', 'income', {...income, ...d})} onPayBill={(b) => { setSelectedBill(b); toggleModal('payment', true); }} onEditBill={(b) => setEditingBill(b)} onRequestIOU={() => toggleModal('iou', true)} onPayIOU={(iou) => { setSelectedIOU(iou); toggleModal('iouPayment', true); }} onClearIOU={(id) => act('delete', 'ious', id)} onApproveIOU={(id) => act('update', 'ious', id, {status: 'approved'})} onDeleteIOU={(id) => act('delete', 'ious', id)} />}
                            {tab === 'shop' && (!isPro ? <Paywall title="Shared Shopping List" description="Sync your grocery runs and wishlist items in real-time." icon={<ShoppingCart size={48} className="text-orange-400"/>} onSubscribe={() => toggleModal('subscription', true)} /> : <ShoppingListView items={shop} onAdd={(d) => act('add', 'shopping', null, d)} onToggle={(id, c) => act('update', 'shopping', id, { completed: c })} onDelete={(id) => act('delete', 'shopping', id)} onFinishShopping={(total) => { const completedItems = shop.filter(i => i.completed); act('add', 'activities', null, { who: profile, description: `Shopping ($${total})`, items: completedItems.map(i => i.text) }); completedItems.forEach(i => act('delete', 'shopping', i.id)); setShoppingMode(false); toggleModal('shoppingComplete', false); }} isShoppingMode={isShoppingMode} setShoppingMode={setShoppingMode} user={profile} />)}
                            {tab === 'goals' && <GoalsView goals={goals} user={profile} onUpdate={(id, d) => act('update', 'goals', id, d)} onDelete={(id) => act('delete', 'goals', id)} />}
                            {tab === 'rewards' && <RewardsView coupons={coupons} currentUser={profile} onRedeem={(c) => setRedeem(c)} />}
                            {tab === 'calendar' && (!isPro ? <Paywall title="Unlock Planning" description="Coordinate your royal schedule with shared events and reminders." icon={<CalendarDays size={48} className="text-pink-400"/>} onSubscribe={() => toggleModal('subscription', true)} /> : <CalendarView events={events} user={profile} onAck={(id) => { const e = events.find((x)=>x.id===id); if(e) act('update', 'events', id, { acks: {...e.acks, [profile]: true} }); }} onDelete={(id) => act('delete', 'events', id)} />)}
                            {tab === 'jokes' && (!isPro ? <Paywall title="Unlock Jokes" description="Track the funniest moments in your kingdom and crown the Court Jester." icon={<Smile size={48} className="text-yellow-400"/>} onSubscribe={() => toggleModal('subscription', true)} /> : <JokesView jokes={jokes} onAdd={(d) => act('add', 'jokes', null, d)} onDelete={(id) => act('delete', 'jokes', id)} user={profile} />)}
                            {tab === 'notes' && (!isPro ? <Paywall title="Unlock Notes" description="Pin important household info, wifi passwords, and love notes." icon={<StickyNote size={48} className="text-blue-400"/>} onSubscribe={() => toggleModal('subscription', true)} /> : <NotesView notes={notes} onAdd={(d) => act('add', 'notes', null, {...d, createdBy: profile, blocks: [{id: '1', text: d.content, author: profile}]})} onDelete={(id) => act('delete', 'notes', id)} onEdit={(note) => setEditingNote(note)} user={profile} />)}
                        </main>
                        <div className="fixed bottom-0 left-0 right-0 w-full px-4 pb-6 pt-12 z-40 flex justify-between items-end pointer-events-none safe-area-pb">
                            <div className="bg-white/95 backdrop-blur-md rounded-[2.5rem] p-1.5 grid grid-cols-2 gap-1 shadow-xl border-4 border-white pointer-events-auto w-[42%]">
                                <NavButton active={tab === 'jokes'} onClick={() => setTab('jokes')} icon={<Smile />} label="Jokes" />
                                <NavButton active={tab === 'dates'} onClick={() => setTab('dates')} icon={<Heart />} label="Dates" />
                                <NavButton active={tab === 'calendar'} onClick={() => setTab('calendar')} icon={<CalendarDays />} label="Plan" />
                                <NavButton active={tab === 'list'} onClick={() => setTab('list')} icon={<CheckCircle />} label="Chores" />
                                <NavButton active={tab === 'assign'} onClick={() => setTab('assign')} icon={<Repeat />} label="Assign" />
                                <div className="flex items-center justify-center opacity-30 grayscale"><span className="text-2xl">{castle.kingdomFlag}</span></div>
                            </div>
                            <div className="pointer-events-auto -mb-6 mx-1 z-50 transform -translate-y-6 flex-1 flex justify-center"><NavButton active={tab === 'castle'} onClick={() => setTab('castle')} icon={<Crown />} label="Kingdom" prominent={true} /></div>
                            <div className="bg-white/95 backdrop-blur-md rounded-[2.5rem] p-1.5 grid grid-cols-2 gap-1 shadow-xl border-4 border-white pointer-events-auto w-[42%]">
                                <NavButton active={tab === 'budget'} onClick={() => setTab('budget')} icon={<PiggyBank />} label="Budget" />
                                <NavButton active={tab === 'notes'} onClick={() => setTab('notes')} icon={<StickyNote />} label="Notes" />
                                <NavButton active={tab === 'shop'} onClick={() => setTab('shop')} icon={<ShoppingCart />} label="Shop" />
                                <NavButton active={tab === 'goals'} onClick={() => setTab('goals')} icon={<Target />} label="Goals" />
                                <div className="flex items-center justify-center opacity-30 grayscale"><span className="text-2xl">{castle.kingdomFlag}</span></div>
                                <NavButton active={tab === 'rewards'} onClick={() => setTab('rewards')} icon={<Gift />} label="Rewards" />
                            </div>
                        </div>

                        {modals.chore && <AddChoreModal onClose={() => toggleModal('chore', false)} onAdd={(d) => { let assigned = null; if (d.isPrettyPlease) assigned = profile === 'Ducky' ? 'Pips' : 'Ducky'; if (d.type === 'whim') assigned = profile; act('add', 'chores', null, { ...d, status: 'pending', assignedTo: assigned, createdBy: profile, votes: {} }); toggleModal('chore', false); }} profile={profile} />}
                        {modals.bill && <AddBillModal onClose={() => toggleModal('bill', false)} onAdd={(d) => { act('add', 'bills', null, { ...d, totalPaid: 0, payments: [] }); toggleModal('bill', false); }} />}
                        {modals.goal && <AddGoalModal onClose={() => toggleModal('goal', false)} onAdd={(d) => { act('add', 'goals', null, { ...d, savedAmount: 0, tasks: [], contributions: [] }); toggleModal('goal', false); }} user={profile} />}
                        {modals.event && <AddEventModal onClose={() => toggleModal('event', false)} onAdd={(d) => { const pl = { ...d, acks: {[profile]: true} }; if(d.type==='shared') pl.acks[profile==='Ducky'?'Pips':'Ducky'] = false; act('add', 'events', null, pl); toggleModal('event', false); }} user={profile} />}
                        {modals.iou && <IOUModal onClose={() => toggleModal('iou', false)} onRequest={(amt, res) => { act('add', 'ious', null, { from: profile, to: profile==='Ducky'?'Pips':'Ducky', amount: parseFloat(amt), reason: res, status: 'pending' }); toggleModal('iou', false); }} />}
                        {modals.meeting && <MeetingModal onClose={() => toggleModal('meeting', false)} chores={chores} events={events} user={profile} onAdd={(d) => act('add', 'chores', null, { ...d, status: 'pending', createdBy: profile, votes: {} })} />}
                        {modals.shop && <AddShoppingModal onClose={() => toggleModal('shop', false)} onAdd={(d) => { act('add', 'shopping', null, d); toggleModal('shop', false); }} user={profile} />}
                        {modals.profile && <ProfileSettingsModal onClose={() => toggleModal('profile', false)} profile={profile} settings={profiles[profile]} onSave={(s) => act('set', 'settings', 'profiles', { ...profiles, [profile]: s })} />}
                        {modals.history && <CastleHistoryModal onClose={() => toggleModal('history', false)} history={historyItems} />}
                        {modals.rewardSettings && <RewardSettingsModal onClose={() => toggleModal('rewardSettings', false)} settings={settings} onUpdateSettings={(newSettings) => { act('set', 'settings', 'rewards', newSettings.rewards); setSettings(newSettings); }} />}
                        {modals.payment && selectedBill && <PaymentModal onClose={() => toggleModal('payment', false)} bill={selectedBill} onPay={(amt) => { const newTotal = (selectedBill.totalPaid || 0) + amt; const newPayments = [...(selectedBill.payments || []), { who: profile, amount: amt, date: new Date().toISOString() }]; act('update', 'bills', selectedBill.id, { totalPaid: newTotal, payments: newPayments }); toggleModal('payment', false); }} />}
                        {modals.shoppingComplete && <ShoppingCompleteModal onClose={() => toggleModal('shoppingComplete', false)} onComplete={(total) => { const completedItems = shop.filter(i => i.completed); act('add', 'activities', null, { who: profile, description: `Shopping ($${total})`, items: completedItems.map(i => i.text) }); completedItems.forEach(i => act('delete', 'shopping', i.id)); setShoppingMode(false); toggleModal('shoppingComplete', false); }} />}
                        {modals.announcement && <AnnouncementModal onClose={() => toggleModal('announcement', false)} onSend={(msg) => { announcements.forEach(a => { if(a.active) act('update', 'announcements', a.id, { active: false }); }); act('add', 'announcements', null, { message: msg, from: profile, active: true }); toggleModal('announcement', false); }} />}
                        {modals.help && <HelpModal onClose={() => toggleModal('help', false)} tab={tab} />}
                        {modals.recurring && <RecurringManagerModal onClose={() => toggleModal('recurring', false)} goals={goals} onDeleteHabit={(goalId, habitId) => { const goal = goals.find(g => g.id === goalId); if (goal && goal.habits) { const newHabits = goal.habits.filter((h) => h.id !== habitId); act('update', 'goals', goalId, { habits: newHabits }); } }} />}
                        {modals.iouPayment && selectedIOU && <IOUPaymentModal onClose={() => { toggleModal('iouPayment', false); setSelectedIOU(null); }} iou={selectedIOU} onPay={(amt) => { const newAmt = selectedIOU.amount - amt; if (newAmt <= 0) act('delete', 'ious', selectedIOU.id); else act('update', 'ious', selectedIOU.id, { amount: newAmt }); toggleModal('iouPayment', false); setSelectedIOU(null); }} />}
                        {modals.castle && <CastleSettingsModal onClose={() => toggleModal('castle', false)} settings={castle} onUpdateSettings={(s) => act('set', 'settings', 'castle', s)} onOpenProfile={() => toggleModal('profile', true)} />}
                        {modals.joke && <AddJokeModal onClose={() => toggleModal('joke', false)} onAdd={(d) => { act('add', 'jokes', null, d); toggleModal('joke', false); }} />}
                        {modals.note && <AddNoteModal onClose={() => toggleModal('note', false)} onAdd={(d) => { act('add', 'notes', null, { ...d, createdBy: profile }); toggleModal('note', false); }} />}
                        
                        {/* Note Editor Modal */}
                        {editingNote && <NoteEditorModal note={editingNote} currentUser={profile} onClose={() => setEditingNote(null)} onDelete={(id) => { act('delete', 'notes', id); setEditingNote(null); }} onSave={(updatedNote) => { act('update', 'notes', updatedNote.id, updatedNote); setEditingNote(null); }} />}
                        
                        {/* Edit Bill Modal */}
                        {editingBill && <EditBillModal bill={editingBill} onClose={() => setEditingBill(null)} onUpdate={(id, d) => act('update', 'bills', id, d)} onDelete={(id) => act('delete', 'bills', id)} />}

                        {/* Conflict Modal */}
                        {conflict && <div className="fixed inset-0 bg-black/60 z-[60] flex items-center justify-center p-6 animate-in fade-in"><div className="bg-white rounded-[2rem] p-6 max-w-sm w-full text-center relative overflow-hidden shadow-2xl border-4 border-white"><div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4"><MessageCircle size={32} className="text-red-500" /></div><h3 className="text-xl font-black text-gray-800 mb-2">Wait, discuss this!</h3><p className="text-gray-500 mb-4 text-sm font-medium">Differing votes for <span className="font-bold text-gray-800">"{conflict.title}"</span>.</p><button onClick={() => setConflict(null)} className="w-full bg-black text-white py-3 rounded-xl font-bold shadow-cute">Okay</button></div></div>}
                        
                        {/* Redeem Modal */}
                        {redeem && <div className="fixed inset-0 bg-black/60 z-[60] flex items-center justify-center p-6 animate-in fade-in"><div className="bg-white rounded-[2rem] p-6 max-w-sm w-full text-center relative overflow-hidden shadow-2xl border-4 border-white"><div className="w-16 h-16 bg-indigo-100 rounded-full flex items-center justify-center mx-auto mb-4"><Gift size={32} className="text-indigo-600" /></div><h3 className="text-xl font-black text-gray-800 mb-2">Redeem?</h3><p className="text-gray-500 mb-6 text-sm font-medium">Use <span className="font-bold text-gray-800">"{redeem.title}"</span>?</p><div className="flex gap-3"><button onClick={() => setRedeem(null)} className="flex-1 py-3 font-bold text-gray-500 hover:bg-gray-100 rounded-xl">Cancel</button><button onClick={() => { act('update', 'coupons', redeem.id, { isUsed: true }); setRedeem(null); }} className="flex-1 bg-indigo-600 text-white py-3 rounded-xl font-bold hover:bg-indigo-700 shadow-cute">Use It!</button></div></div></div>}
                        
                        {/* Subscription Modal */}
                        {modals.subscription && (
                            <ModalWrapper onClose={() => toggleModal('subscription', false)} title="Kingdom Pro" icon={<Star className="text-yellow-400" size={28}/>}>
                                <div className="space-y-6 text-center">
                                    <div className="bg-gradient-to-br from-yellow-100 to-orange-100 p-6 rounded-3xl border-2 border-yellow-200">
                                        <h3 className="text-xl font-black text-yellow-800 mb-2">Unlock the Full Kingdom</h3>
                                        <p className="text-sm text-yellow-700 font-medium leading-relaxed">Upgrade your castle to access premium tools for organizing your royal life.</p>
                                    </div>
                                    <div className="space-y-3 text-left">
                                        <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl"><div className="bg-blue-100 p-2 rounded-lg text-blue-500"><CalendarDays size={20}/></div><span className="font-bold text-gray-700 text-sm">Advanced Planning Calendar</span></div>
                                        <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl"><div className="bg-orange-100 p-2 rounded-lg text-orange-500"><ShoppingCart size={20}/></div><span className="font-bold text-gray-700 text-sm">Shared Shopping List</span></div>
                                        <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl"><div className="bg-yellow-100 p-2 rounded-lg text-yellow-500"><Smile size={20}/></div><span className="font-bold text-gray-700 text-sm">Joke Tracker & Leaderboard</span></div>
                                        <div className="flex items-center gap-3 p-3 bg-gray-50 rounded-xl"><div className="bg-purple-100 p-2 rounded-lg text-purple-500"><StickyNote size={20}/></div><span className="font-bold text-gray-700 text-sm">Royal Scribe Notes</span></div>
                                    </div>
                                    
                                    {!isPro ? (
                                        <div className="space-y-2">
                                            <button 
                                                onClick={handleSubscribe} 
                                                className="w-full bg-black text-white py-4 rounded-2xl font-black shadow-lg hover:scale-[1.02] active:scale-95 transition-all flex items-center justify-center gap-2"
                                            >
                                                Subscribe for $14.99/mo <ArrowRight size={18}/>
                                            </button>
                                            
                                            <div className="text-[10px] text-gray-400 mt-2 text-center">
                                                Secure payment via Stripe. <br/>
                                                <button onClick={() => window.location.reload()} className="underline font-bold text-gray-500 hover:text-black mt-1">Already paid? Refresh.</button>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="space-y-4">
                                            <div className="bg-green-100 text-green-700 py-3 rounded-xl font-bold border border-green-200">
                                                You are a Pro Member! üåü
                                            </div>
                                            <button 
                                                onClick={() => window.location.reload()} 
                                                className="w-full py-3 bg-gray-100 text-gray-600 rounded-xl font-bold text-xs flex items-center justify-center gap-2 hover:bg-gray-200"
                                            >
                                                <RefreshCcw size={14}/> Force Refresh Status
                                            </button>
                                            <button 
                                                onClick={handleManageSubscription} 
                                                className="w-full py-3 bg-white border-2 border-gray-100 text-gray-600 rounded-xl font-bold text-xs flex items-center justify-center gap-2 hover:bg-gray-50"
                                            >
                                                Manage / Cancel Subscription <ExternalLink size={12}/>
                                            </button>
                                        </div>
                                    )}
                                    
                                    {debugLogs.length > 0 && (
                                        <div className="mt-4 p-3 bg-black text-green-400 font-mono text-[10px] rounded-xl text-left h-40 overflow-y-auto border-2 border-gray-800 shadow-inner">
                                            <div className="font-bold text-gray-500 mb-1 border-b border-gray-800 pb-1">DEBUG CONSOLE</div>
                                            {debugLogs.map((log, i) => <div key={i} className="whitespace-pre-wrap">{log}</div>)}
                                        </div>
                                    )}
                                    <p className="text-[10px] text-red-300 mt-2 font-mono bg-red-50 p-1 rounded">Debug: {subscription.debug || 'None'}</p>
                                </div>
                            </ModalWrapper>
                        )}
                    </div>
                </ErrorBoundary>
            );
        }